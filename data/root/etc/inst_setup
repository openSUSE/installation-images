#! /bin/sh

yast="$1"
shift
echo $yast > /tmp/linuxrc_installer_name
export YAST2_SSH=false
unset SSH_FAILED

exec 2>&1
stty sane

echo -en \\033c

# linuxrc passes the root directory of the freshly mounted instsys in
# the environment variable INSTSYS.
#

# this script will symlink from the initrd to all files and
# directories missing.

# a few files should be restored when installation has completed if we
# return to linuxrc.
FILES_TO_RESTORE="/etc/ld.so.cache"
for file in $FILES_TO_RESTORE
do
    test -e $file && mv $file $file.initrd
done


echo "integrating the installation system into the ramdisk..."
$INSTSYS/usr/bin/conservative_lndir "$INSTSYS" "/"

echo "integrating the shared objects of the installation system..."
ldconfig

if test -x /sbin/syslogd
then
    checkproc /sbin/syslogd || {
	echo "starting syslog (messages are logged to /dev/tty4)..."
	/sbin/syslogd
    }
fi

if test -x /sbin/klogd
then
    checkproc /sbin/klogd || {
	echo "starting klogd ..."
	/sbin/klogd -f /dev/null -c 1
}
fi

arch=$(uname -m)

case "$arch" in
  i?86)
    # remove modules to free memory
    if [ "$REMOVE_MODULES" = 1 ] ; then
      rm -f /modules/*
    fi
  ;;
esac

# create a new modules.dep
#
# modules from initrd (in /modules) are preferred over those from CD (below
# /lib/modules)
#
rm -f /etc/modules.conf
cp "$INSTSYS/etc/modules.conf" /etc
cat >>/etc/modules.conf <<EOF
path=/modules
path=/lib/modules/`uname -r`
depfile=/etc/modules.dep
generic_stringfile=/etc/modules.generic_string
pcimapfile=/etc/modules.pcimap
isapnpmapfile=/etc/modules.isapnpmap
usbmapfile=/etc/modules.usbmap
parportmapfile=/etc/modules.parportmap
ieee1394mapfile=/etc/modules.ieee1394map
pnpbiosmapfile=/etc/modules.pnpbiosmap
EOF

echo "integrating kernel modules of the installation system..."
depmod -a 2>/dev/null

# exists only on s390
test -r /etc/netsetup.inf && cat /etc/netsetup.inf >> /etc/install.inf

# boot with usessh=1 or use linuxrc to enable ssh 
if grep -q "^UseSSH:.*1" /etc/install.inf ; then
	test -x /sbin/inst_setup_ssh  &&  . /sbin/inst_setup_ssh
fi

# for yast debugging.
grep -iwq < /proc/cmdline debug && {
export Y2DEBUG=1
export Y2MAXLOGSIZE=50000
export Y2MAXLOGNUM=5
test -d $INSTSYS/root/.yast2 && cp -a $INSTSYS/root/.yast2 /root
}


# yast1 doesn't like it
rm -f /etc/fstab

# start shell, useful on iSeries or via serial console
grep -qwi start_shell /proc/cmdline && {
echo 
echo "ATTENTION"
echo "Starting shell... (use 'exit' to proceed)"
bash --init-file /root/.bash_login
}

ec=
if [ "$YAST2_SSH" = "true" ] ; then
cat <<EOF

           *** login via ssh: root@`hostname` ***
      *** run '$yast' to start the installation ***

EOF
while true ; do
#echo -n .
sleep 3
# this file is created from YaST2.firstboot after installation
test ! -f /tmp/YaST2_ssh_installation_finished && continue
# you can touch this file to keep the ssh shell
# useful for debugging the installer
test -f /tmp/YaST2_keep_sshd_running && continue
break
done

ec=$(cat /tmp/YaST2_ssh_installation_finished)
rm -f /tmp/YaST2_ssh_installation_finished
elif [ "$yast" = yast ] ; then
# now, run yast
echo "starting yast..."
  /sbin/yast "$@" ; ec=$?
elif [ "$yast" ] ; then
# now, run yast
echo "starting $yast..."
  "$yast" "$@" ; ec=$?
fi

# start shell, useful on iSeries or via serial console
grep -qwi start_shell /proc/cmdline && {
echo
echo "ATTENTION"
echo "Starting shell... (use 'exit' to proceed)"
bash --init-file /root/.bash_login
}

test -r /etc/netsetup.inf && cat /etc/netsetup.inf >> /etc/install.inf
# still needed?
#[ $ec -ne 0 ] && echo "An Error happened during installation"
#ec=0

# stop vnc
killall Xvnc 2>/dev/null >/dev/null
# stop sshd
killall sshd 2>/dev/null >/dev/null

umount devpts 2>/dev/null

for file in $FILES_TO_RESTORE
do
    test -e $file.initrd && mv $file.initrd $file
done


exit $ec
