#! /bin/sh
#

#                              ***  NOTE  ***
#
# linuxrc now takes care of integrating the instsys. No need to fiddle with
# symlinks and such here.
#
# linuxrc-based tools are in /lbin.
#

PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/lib/YaST2/bin:/usr/X11/bin

# see bug 46535
[ -e /proc/sys/vm/local-oom-kill ] && echo 1 > /proc/sys/vm/local-oom-kill

if [ -f /.timestamp ] ; then
  read build_time < /.timestamp
  now_time=`TZ= LANG= LC_ALL= date +%Y%m%d`
  if [ "$now_time" -lt "$build_time" ] ; then
       echo
       echo "your system time is not correct:"
       TZ= date
       echo "setting system time to:"
       TZ= LANG= LC_ALL= date ${build_time#????*}1234${build_time%*????}.56
       echo
       sleep 3
  fi
fi

if [ -d /dev/pts ] ; then
  grep -q devpts /proc/mounts || mount -t devpts devpts /dev/pts
fi

if [ -x /sbin/udev -a -x /sbin/udevstart ] ; then
echo -n "creating device nodes .."
/sbin/udevstart
echo ". done"
fi
# FIXME fix udev to not delete valid device nodes
# /proc/self/fd/N will fail
exec < /dev/console > /dev/console 2>&1 3>&1

if [ ! -x /sbin/hotplug -a -x /sbin/udev ] ; then
echo using udev as hotplug helper
echo /sbin/udev > /proc/sys/kernel/hotplug
fi

yast="$1"
shift
echo $yast > /tmp/linuxrc_installer_name
export YAST2_SSH=false
unset SSH_FAILED
stty sane

if [ -s /etc/install.inf ]; then
  hostname=`sed -n -e 's,^Hostname: ,,p' /etc/install.inf`
else
  hostname=`hostname`
fi
#
# kernel 2.6 uses linuxkeycodes for all keyboards
# 2.4 kernels may still use ADB keycodes, but all the maps have the new encoding 
# since post 9.0. Just switch the kernel side if the default is still ADB
test -f /proc/sys/dev/mac_hid/keyboard_sends_linux_keycodes && echo 1 > /proc/sys/dev/mac_hid/keyboard_sends_linux_keycodes

#
# echo -en \\033c
#
# linuxrc passes the root directory of the freshly mounted instsys in
# the environment variable INSTSYS.
#
# a few files should be restored when installation has completed if we
# return to linuxrc.
FILES_TO_RESTORE="/etc/ld.so.cache"
for file in $FILES_TO_RESTORE
do
    test -e $file && mv $file $file.initrd
done
#

# effectively makes the kernel module dir tree writable
/lbin/lndir $INSTSYS/lib/modules /lib/modules
# make depmod happy if the running kernel doesnt match
mkdir -p /lib/modules/`uname -r`

echo "integrating the shared objects of the installation system..."
ldconfig

# driver update: rebuild yast update tree
[ -L /y2update ] && rm -f /y2update
[ -d /update/y2update ] && mv /update/y2update /update/y2update.bak
for i in /update/[0-9]*/y2update ; do
  [ -d "$i" ] && cp -a "$i" /update
done
if [ -d /update/y2update ] ; then
  rm -rf /update/y2update.bak
else
  [ -d /update/y2update.bak ] && mv /update/y2update.bak /update/y2update
fi

# driver update: add files to inst-sys
for i in /update/[0-9]*/inst-sys ; do
  [ -d "$i" ] && adddir "$i" /
done

# driver update: run update.pre scripts
for i in /update/[0-9]*/install/update.pre ; do
  [ -x "$i" ] && "$i"
done

if test -x /sbin/syslogd
then
    checkproc /sbin/syslogd || {
	echo "starting syslog (messages are logged to /dev/tty4)..."
	sh -c '/sbin/syslogd >&1'
    }
fi

if test -x /sbin/klogd
then
    checkproc /sbin/klogd || {
	echo "starting klogd ..."
	/sbin/klogd -c 1
}
fi

arch=$(uname -m)

case "$arch" in
  i?86)
    # remove modules to free memory
    if [ "$REMOVE_MODULES" = 1 ] ; then
      rm -f /modules/*
    fi
  ;;
esac

# Update module config.
#
# Note: modules from initrd are below *-override-* and will take precedence.
#
echo "integrating kernel modules of the installation system..."
depmod -a 2>/dev/null

# exists only on s390
test -r /etc/netsetup.inf && cat /etc/netsetup.inf >> /etc/install.inf

# boot with usessh=1 or use linuxrc to enable ssh 
if grep -q "^UseSSH:.*1" /etc/install.inf ; then
	test -x /sbin/inst_setup_ssh  &&  . /sbin/inst_setup_ssh
fi

# for yast debugging.
grep -iwq y2debug < /proc/cmdline && {
export Y2DEBUG=1
export Y2MAXLOGSIZE=50000
export Y2MAXLOGNUM=5
test -d $INSTSYS/root/.yast2 && cp -a $INSTSYS/root/.yast2 /root
}

export XCURSOR_THEME=crystalwhite

# yast1 doesn't like it
rm -f /etc/fstab

# start shell, useful on iSeries or via serial console
rm -f /.start_shell
grep -qwi start_shell /proc/cmdline && echo 42 > /.start_shell
function start_shell() {
echo 
echo "ATTENTION"
echo "Starting shell... (use 'exit' to proceed)"
bash --init-file /root/.bash_login
}

if [ -f /.start_shell ] ; then
	start_shell
fi

# anounce VNC via slpd
if grep -qi "^VNC:.*1" /etc/install.inf ; then
	echo starting slpd to anounce VNC...
	test -x /usr/sbin/slpd  &&  /usr/sbin/slpd
	/usr/bin/slptool register "service:YaST.installation.suse:vnc://${hostname}:5901"
fi

ec=
if [ "$YAST2_SSH" = "true" ] ; then
cat <<EOF

      ***  login using 'ssh -X root@${hostname}'  ***
      ***  run '$yast' to start the installation  ***

EOF
while true ; do
#echo -n .
sleep 3
# this file is created from YaST2.firstboot after installation
test ! -f /tmp/YaST2_ssh_installation_finished && continue
# you can touch this file to keep the ssh shell
# useful for debugging the installer
test -f /tmp/YaST2_keep_sshd_running && continue
break
done

ec=$(cat /tmp/YaST2_ssh_installation_finished)
rm -f /tmp/YaST2_ssh_installation_finished
elif [ "$yast" = yast ] ; then
# now, run yast
echo "starting yast..."
  /sbin/yast "$@" ; ec=$?
elif [ "$yast" ] ; then
# now, run yast
echo "starting $yast..."
  "$yast" "$@" ; ec=$?
fi

# start shell, useful on iSeries or via serial console
if [ -f /.start_shell ] ; then
	start_shell
fi

test -r /etc/netsetup.inf && cat /etc/netsetup.inf >> /etc/install.inf
# still needed?
#[ $ec -ne 0 ] && echo "An Error happened during installation"
#ec=0

# stop slpd
killall slpd 2>/dev/null >/dev/null
# stop vnc
killall Xvnc 2>/dev/null >/dev/null
# stop sshd
killall sshd 2>/dev/null >/dev/null

umount devpts 2>/dev/null

for file in $FILES_TO_RESTORE
do
    test -e $file.initrd && mv $file.initrd $file
done

rm -f /etc/modules.conf
rm -f /.start_shell

exit $ec
