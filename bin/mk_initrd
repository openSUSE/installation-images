#! /usr/bin/perl

# Create an initrd and put everything on it.
#
# Source files and the file list are taken from data/initrd; the initrd is
# stored in images/initrd.
#
# Usage:        mk_initrd

=head1 mk_initrd

C<mk_initrd> creates an initial ram disk C<initrd>.

The files to go onto the ram disk (aka initrd) are taken from
C<data/initrd/initrd.file_list>.

The initrd uses a Ext2 file system. The actual fs size and inode numbers
are coded in the C<mk_initrd> script. You I<can> vary these values but it
doesn't really pay of much. You will gain or loose a few bytes of the
compressed initrd size only.

The final compressed image is stored as C<images/initrd>.

=cut

#'quote for emacs

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# the usual fuss...

BEGIN { unshift @INC, ( $0 =~ /(.*?)((?<![^\/])bin\/)?[^\/]+$/ )[0] . "lib" }
use ReadConfig;
use MakeMinixImage;
use MakeExt2Image;
use AddFiles;
use Conv2Image;

die "usage: $Script\n" if @ARGV;


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# some config data

$srcdir = "${DataPath}initrd";
$tmpdir = "${BasePath}tmp/initrd";
$moddir = "${BasePath}tmp/initrd/modules";
$modlist = "${BasePath}tmp/initrd.modlist";
$tmpdirx = "${BasePath}tmp/.initrd";
$image = "${ImagePath}initrd";
$arch = "$ConfigData{suse_arch}";

# the compressed image size varies only slightly with these; about +-1k with
# reasonable inode/block combinations

# leave that much space
$extra_size = 600;		# kbyte
$extra_inodes = 200;

# just make them large enough
$start_size = 40000;		# kbyte
$start_inodes = 7000;

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# now we really start...

if($ENV{'keepinitrd'} != 1) {
  # clean up
  if(-d $tmpdir) {
    SUSystem "rm -rf $tmpdir" and
      die "$Script: failed to remove old $tmpdir";
  }
  if(-d $tmpdirx) {
    SUSystem "rm -rf $tmpdirx" and
      die "$Script: failed to remove old $tmpdirx";
  }

  SUSystem "rm -f ${BasePath}tmp/initrd.opt_mods";
  SUSystem "rm -f $modlist";

  $fl = "initrd";
  $fl = $ENV{'filelist'} if exists $ENV{'filelist'};

  AddFiles $tmpdir, "${srcdir}/$fl.file_list", $srcdir, $ENV{'initrd'}, "${BasePath}tmp/initrd.opt_mods" or
    die "$Script: failed to setup initrd image";

  SUSystem "sh -c 'cd $tmpdir; ./makedevs.floppy >/dev/null'" and
    die "$Script: could not create all devices";
  SUSystem "rm $tmpdir/makedevs.floppy";

  # strip everything
  SUSystem "strip_dir $tmpdir";
}

# on S/390, the contains shared objects
if ($arch eq 's390' || $arch eq 's390x') {
    SUSystem "ldconfig -r $tmpdir";
    die "$Script: failed to run ldconfig" unless -f "$tmpdir/etc/ld.so.cache";

    if($debug =~ /\bignore\b/ || $debug =~ /\bignorelibs\b/) {
      system "check_libs $tmpdir" and
	warn "$Script: error in shared lib config, please fix\n";
    }
    else {
      system "check_libs $tmpdir" and
	die "$Script: error in shared lib config, please fix\n";
    }    
}

@m = `ls $moddir/*.o 2>/dev/null`;
for (@m) {
  chomp;
  s#.*/##;
  s/\.o$//;
  push @m1, "$_\n"
}

open F, ">$modlist";
print F @m1;
close F;

# create the image
# alternatively, check if ENV{initrd} eq 'small'
$fstype = $arch eq 'i386' ? 'minix' : 'ext2';
Conv2Image $image, $tmpdir, $fstype, $start_size, $start_inodes, $extra_size, $extra_inodes;

# compress it
system "gzip -f -9 $image" and die "$Script: gzip failed";
rename "${image}.gz", "$image";

$i = -s "$image";
print "$Script: compressed initrd to \"$image\" ($i bytes)\n";
